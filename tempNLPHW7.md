-2.a.2
> 0 (0|1)* 111 1?

> Basic string FSTs are defined by text enclosed by double quotes ("). (Note that raw strings, such as those used in filenames, are enclosed by single quotes (') instead.) They can be parsed in one of three ways, which are denoted using a dot (.) followed by either byte, utf8, or an identifier holding a symbol table. Note that within strings, the backslash character (\) is used to escape the next character. Of particular note, \n translates into a newline, \r into a line feed, and \t into the tab character. Literal left and right square brackets will also need escaping, as they are used natively to generate symbols (see below). All other characters following the backslash are uninterpreted, so that we can use \" and \' to insert an actual quote (double) quote symbol instead of terminating the string.


-2.a.3
> States: 5, Arcs: 9



-2.b.1
> [Zero Bit* One One One]

-2.b.2
> No string should be accept if they are same.

> Yes, The output has 0 state, 0 arc and -1 initial state. It implies First and Second are same. Otherwise, we will have some ouput which is can be generated by First but not Second or by Second but not First.

-2.c.1

=== First.fst ===
> States: 20, Arcs: 25

=== Second.fst ===
> States: 13, Arcs: 16

=== Disagreements.fst ===
> States: 88, Arcs: 113

-2.c.2
> Without calling Optimize[], We can considered the regexp of Disagreements into two cases, therefore the drawing shows two separate sub-FSAs. In fact, without optimization, even the drawing of the case " First | First " will show that it immediatelly branches at the start state into two separate sub-FSAs. 

-2.c.3
> It should be same, cause the regexp of two cases are same.

-2.d
> Same as the result of binary.grm. Since there is no sentence can be generated using FSA of Disagreements, the FASs will be empty after optimization.


-3.a

> Triple = One One One+;
>> export Triplets = (Zero* Triple*)*;

-3.b

> export NotPillars = (Zero* One*)* - Disagreements - Evens ;

-3.c

> export Oddlets = Odds? (Zero+ Odds)* Zero* ;

-4.a

> a (b* | c+ | empty) a

-4.b

> a, aba, aa, aca 

-4.c

> ?

-4.d

> States: 10, Arcs: 16


-5.

```
Bit = "0" | "1" ;
Digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";

# 4.
export Cross = Optimize["a" (("b":"x")* | ("c"+ : "y"*) | ("":"fric")) "a"];

# 5.
# (a.)
export BitFlip1 = ( ("0":"1") | ("1":"0") )* ;

# (b.)
export BitFlip2 = CDRewrite[BitFlip1, ""  , "" , Digit*, 'sim', 'obl' ] ;

# (c.)
export Parity1 =  ( (Bit Bit)* : "0" ) | ( Bit* - (Bit Bit)*  : "1" ) ;

# (d.)
export Parity2 = Reverse[Parity1] ;

# (e.)
export Parity3 = CDRewrite[ Parity1, "[BOS]", "[EOS]", Bit*, 'ltr', 'obl' ] ;

# (f.)
export UnParity = Invert[Parity3] ; # inverse function, valid inpur 1,0

# (g.)
export Split = CDRewrite[ ( ("1" : ("1 "| "1" )) | ("0":("0 "| "0")) )* , "[BOS]" , Bit "[EOS]" , (Bit | " ")*, 'sim', 'obl' ] ;

# (h.)
Threeway = Bit+ " " Bit+ " " Bit+ ;
export SplitThree = Split @ Threeway ;
```

-6.a.2

> States: 16, Arcs: 20

-6.b

```
# (a.)
export NP = Optimize[( "Art" | "Quant" )? "Adj"* "Noun"+ ] ;

# (b.)
export MakeNmod = CDRewrite[ ("Noun" : "Nmod")*  , "" , "Noun" (tags.Tags-"Noun")*, tags.Tags* ,'sim', 'obl' ]  ;

# (c.)
export TransformNP = Optimize[NP @ MakeNmod];

```

-6.c

i. The transducer only takes input in NP format and replaces "Noun" with "Nmod" before any "Noun", otherwise return "Rewrite failed."

ii. 
```
Input string: ArtAdjNounNounNoun
Output string: ArtAdjNmodNmodNoun

Input string: AdjNounNounNounVerb
Rewrite failed.
```

iii.

Much smaller since all the possible output of NP is a subset of the output of tag.Tags*, the ouput of TransformNP is smaller than MakeNmod.

iv.

The size of TransformNP is same as the size of NP. For any possible ouput of NP, we can pair it with an unique ouput of TransformNP. Vice versa.

-6.d

BracketNP only takes NP and convert it into <NP>

Brackets1 takes SigmaStar (NP SigmaStar)* and converts it into SigmaStar (<NP> SigmaStar)*. 

Brackets2 convert any possible NP into <NP>.

The difference between Brackets2 and Brackets1 is that Brackets1 can leave the NP as NP ( since NP is a subset of SigmaStar ), but Brackets2 wil convert all possible NP to <NP>.

-6.e

-6.f

-6.g

-7.a

```
export OneNucleus =  Consonant* ("":"'") Nucleus Consonant* ;
export AddStress123 =  CDRewrite[ ("" : "'" ) Nucleus  ,  ("[BOS]" Consonant* | Consonant+ Nucleus Consonant+ ) , ( Consonant+ Nucleus ), Sigma*, 'ltr', 'obl' ] ;
export Stress = AddStress123 @ ( OneNucleus | Sigma* - (Consonant* Nucleus Consonant*) ) ;

export BackwardStress = Invert[Stress] ;
```

-7.b
```
Input string: ev'apor'ating
Output string: ev'aporating
Output string: ev'apor'ating

Input string: 'incomm'unic'ado
Output string: incomm'unic'ado
Output string: incommunic'ado
Output string: incommunicado
Output string: 'incommunic'ado
Output string: 'incommunicado
Output string: 'incomm'unicado
Output string: incomm'unicado
Output string: 'incomm'unic'ado
```

-7.c

```
export StressWords = CDRewrite[Stress, (" " | "[BOS]" ), ( " " | "[EOS]" ) , bytelib.kBytes*, 'ltr', 'obl' ] ;
```



-7.d
```
export CheckY = CDRewrite[ ("y":"_") | ("Y" | "^") , "[BOS]" | Consonant+ , Consonant+ | ( Nucleus*  "[EOS]") , ("_" |Sigma | "^")*, 'ltr' , 'obl' ] ;

# consider yes,yea.... y should be consonant in this case
export CheckYforYes = CheckY @( ((("^":"Y") | ("_":"y")) Nucleus ) | ( (Sigma | "^" | "_" )* - (("^"|"_") Nucleus ) ) ) ;

NewVowel = Vowel | "^" | "_" ;
NewConsonant = Letter - NewVowel ;
NewNucleus = NewVowel+ ;

export OneNucleusY =  NewConsonant* ("":"'") NewNucleus NewConsonant* ;
export AddStress123Y =  CDRewrite[ ("" : "'" ) NewNucleus  ,  ("[BOS]" NewConsonant* | NewConsonant+ NewNucleus NewConsonant+ ) , ( NewConsonant+ NewNucleus ), (Sigma | "^" | "_" )* , 'ltr', 'obl' ] ;
export StressY = AddStress123Y @ ( OneNucleusY | (Sigma | "^" | "_" )* - (NewConsonant* NewNucleus NewConsonant*) ) ;
export test = CheckYforYes @ StressY @ CDRewrite[ ("_":"y") | ("^" | "Y") , "", "" , (Sigma | "^" | "_" )* , 'ltr', 'obl' ] ;
```

-8.a

stove/ move/ love

-8.b

-8.c

The regular language defined by Results is starting with 1 stressed vowel which followed by 2 unstressed vowel and repeat. 

> ( Stressed_Vowel Unstressed_Vowel Unstressed_Vowel )* 

> ex. ordering      AO1 R D ER0 IH0 NG

```
# legal example
export Pronounce = StringFile[’data/cmudict.txt’];
input: ordering
output: AO1 R D ER0 IH0 NG

export StressPattern = CDRewrite[(Sigma-bytelib.kDigit) : "", "","",Sigma*,’sim’,’obl’];
input: AO1 R D ER0 IH0 NG
output: 100

# ( 1 stressed vowel followed by 2 unstressed vowel )*
export Dacytl = ("1" | "2") "0" "0"; 
input: 100
output: 100

# Therefore, combining all of this
export Results = Optimize[Project[Pronounce @ StressPattern @ (Dacytl*), ’input’]];
input: ordering
output: ordering
```

> ordinances      AO1 R D AH0 N AH0 N S IH0 Z

```
# illegal example
export Pronounce = StringFile[’data/cmudict.txt’];
input: ordinances
output: AO1 R D AH0 N AH0 N S IH0 Z

export StressPattern = CDRewrite[(Sigma-bytelib.kDigit) : "", "","",Sigma*,’sim’,’obl’];
input: AO1 R D AH0 N AH0 N S IH0 Z
output: 1000

# ( 1 stressed vowel followed by 2 unstressed vowel )*
export Dacytl = ("1" | "2") "0" "0"; 
input: 1000
Rewrite failed.

# Therefore, combining all of this
export Results = Optimize[Project[Pronounce @ StressPattern @ (Dacytl*), ’input’]];
input: ordinances
Rewrite failed.
```



