-2.a.2
> 0 (0|1)* 111 1?

> Basic string FSTs are defined by text enclosed by double quotes ("). (Note that raw strings, such as those used in filenames, are enclosed by single quotes (') instead.) They can be parsed in one of three ways, which are denoted using a dot (.) followed by either byte, utf8, or an identifier holding a symbol table. Note that within strings, the backslash character (\) is used to escape the next character. Of particular note, \n translates into a newline, \r into a line feed, and \t into the tab character. Literal left and right square brackets will also need escaping, as they are used natively to generate symbols (see below). All other characters following the backslash are uninterpreted, so that we can use \" and \' to insert an actual quote (double) quote symbol instead of terminating the string.


-2.a.3
> States: 5, Arcs: 9



-2.b.1
> [Zero Bit* One One One]

-2.b.2
> No string should be accept if they are same.

> Yes, The output has 0 state, 0 arc and -1 initial state. It implies First and Second are same. Otherwise, we will have some ouput which is can be generated by First but not Second or by Second but not First.

-2.c.1

=== First.fst ===
> States: 20, Arcs: 25

=== Second.fst ===
> States: 13, Arcs: 16

=== Disagreements.fst ===
> States: 88, Arcs: 113

-2.c.2
Without calling Optimize[], We can considered the regexp of Disagreements into two cases, therefore the drawing shows two separate sub-FSAs. In fact, without optimization, even the drawing of the case " First | First " will show that it immediatelly branches at the start state into two separate sub-FSAs. 

-2.c.3
It should be same, cause the regexp of two cases are same.

-2.d
Same as the result of binary.grm. Since there is no sentence can be generated using FSA of Disagreements, the FASs will be empty after optimization.


-3.a

>Triple = One One One+;
>export Triplets = (Zero* Triple*)*;




