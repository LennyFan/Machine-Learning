-2.a.2
> 0 (0|1)* 111 1?

> Basic string FSTs are defined by text enclosed by double quotes ("). (Note that raw strings, such as those used in filenames, are enclosed by single quotes (') instead.) They can be parsed in one of three ways, which are denoted using a dot (.) followed by either byte, utf8, or an identifier holding a symbol table. Note that within strings, the backslash character (\) is used to escape the next character. Of particular note, \n translates into a newline, \r into a line feed, and \t into the tab character. Literal left and right square brackets will also need escaping, as they are used natively to generate symbols (see below). All other characters following the backslash are uninterpreted, so that we can use \" and \' to insert an actual quote (double) quote symbol instead of terminating the string.


-2.a.3
> States: 5, Arcs: 9



-2.b.1
> [Zero Bit* One One One]

-2.b.2
> No string should be accept if they are same.

> Yes, The output has 0 state, 0 arc and -1 initial state. It implies First and Second are same. Otherwise, we will have some ouput which is can be generated by First but not Second or by Second but not First.

-2.c.1

=== First.fst ===
> States: 20, Arcs: 25

=== Second.fst ===
> States: 13, Arcs: 16

=== Disagreements.fst ===
> States: 88, Arcs: 113

-2.c.2
> Without calling Optimize[], We can considered the regexp of Disagreements into two cases, therefore the drawing shows two separate sub-FSAs. In fact, without optimization, even the drawing of the case " First | First " will show that it immediatelly branches at the start state into two separate sub-FSAs. 

-2.c.3
> It should be same, cause the regexp of two cases are same.

-2.d
> Same as the result of binary.grm. Since there is no sentence can be generated using FSA of Disagreements, the FASs will be empty after optimization.


-3.a

> Triple = One One One+;
>> export Triplets = (Zero* Triple*)*;

-3.b

> export NotPillars = (Zero* One*)* - Disagreements - Evens ;

-3.c

> export Oddlets = Odds? (Zero+ Odds)* Zero* ;

-4.a

> a (b* | c+ | empty) a

-4.b

> a, aba, aa, aca 

-4.c

> ?

-4.d

> States: 10, Arcs: 16


-5.

```
Bit = "0" | "1" ;
Digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";

# 4.
export Cross = Optimize["a" (("b":"x")* | ("c"+ : "y"*) | ("":"fric")) "a"];

# 5.
# (a.)
export BitFlip1 = ( ("0":"1") | ("1":"0") )* ;

# (b.)
export BitFlip2 = CDRewrite[BitFlip1, ""  , "" , Digit*, 'sim', 'obl' ] ;

# (c.)
export Parity1 =  ( (Bit Bit)* : "0" ) | ( Bit* - (Bit Bit)*  : "1" ) ;

# (d.)
export Parity2 = Reverse[Parity1] ;

# (e.)
export Parity3 = CDRewrite[ Parity1, "[BOS]", "[EOS]", Bit*, 'ltr', 'obl' ] ;

# (f.)
export UnParity = Invert[Parity3] ; # inverse function, valid inpur 1,0

# (g.)
export Split = CDRewrite[ ( ("1" : ("1 "| "1" )) | ("0":("0 "| "0")) )* , "[BOS]" , Bit "[EOS]" , (Bit | " ")*, 'sim', 'obl' ] ;

# (h.)
Threeway = Bit+ " " Bit+ " " Bit+ ;
export SplitThree = Split @ Threeway ;
```

-6.a.2

> States: 16, Arcs: 20

-6.b

```
# (a.)
export NP = Optimize[( "Art" | "Quant" )? "Adj"* "Noun"+ ] ;

# (b.)
export MakeNmod = CDRewrite[ ("Noun" : "Nmod")*  , "" , "Noun" (tags.Tags-"Noun")*, tags.Tags* ,'sim', 'obl' ]  ;

# (c.)
export TransformNP = Optimize[NP @ MakeNmod];

```

-6.c

i. The transducer only takes input in NP format and replaces "Noun" with "Nmod" before any "Noun", otherwise return "Rewrite failed."

ii. 
```
Input string: ArtAdjNounNounNoun
Output string: ArtAdjNmodNmodNoun

Input string: AdjNounNounNounVerb
Rewrite failed.
```

iii.

Much smaller since all the possible output of NP is a subset of the output of tag.Tags*, the ouput of TransformNP is smaller than MakeNmod.

iv.

The size of TransformNP is same as the size of NP. For any possible ouput of NP, we can pair it with an unique ouput of TransformNP. Vice versa.

-6.d

BracketNP only takes NP and convert it into <NP>

Brackets1 takes SigmaStar (NP SigmaStar)* and converts it into SigmaStar (<NP> SigmaStar)*. 

Brackets2 convert any possible NP into <NP>.

The difference between Brackets2 and Brackets1 is that Brackets1 can leave the NP as NP ( since NP is a subset of SigmaStar ), but Brackets2 wil convert all possible NP to <NP>.

-6.e

-6.f

-6.g

-7.a

```
export OneNucleus =  Consonant* ("":"'") Nucleus Consonant* ;
export AddStress123 =  CDRewrite[ ("" : "'" ) Nucleus  ,  ("[BOS]" Consonant* | Consonant+ Nucleus Consonant+ ) , ( Consonant+ Nucleus ), Sigma*, 'ltr', 'obl' ] ;
export Stress = AddStress123 @ ( OneNucleus | Sigma* - (Consonant* Nucleus Consonant*) ) ;

export BackwardStress = Invert[Stress] ;
```

-7.b
```
Input string: ev'apor'ating
Output string: ev'aporating
Output string: ev'apor'ating

Input string: 'incomm'unic'ado
Output string: incomm'unic'ado
Output string: incommunic'ado
Output string: incommunicado
Output string: 'incommunic'ado
Output string: 'incommunicado
Output string: 'incomm'unicado
Output string: incomm'unicado
Output string: 'incomm'unic'ado
```

-7.c

```
export StressWords = CDRewrite[Stress, (" " | "[BOS]" ), ( " " | "[EOS]" ) , bytelib.kBytes*, 'ltr', 'obl' ] ;
```



-7.d
```
export CheckY = CDRewrite[ ("y":"_") | ("Y" | "^") , "[BOS]" | Consonant+ , Consonant+ | ( Nucleus*  "[EOS]") , ("_" |Sigma | "^")*, 'ltr' , 'obl' ] ;

# consider yes,yea.... y should be consonant in this case
export CheckYforYes = CheckY @( ((("^":"Y") | ("_":"y")) Nucleus ) | ( (Sigma | "^" | "_" )* - (("^"|"_") Nucleus ) ) ) ;

NewVowel = Vowel | "^" | "_" ;
NewConsonant = Letter - NewVowel ;
NewNucleus = NewVowel+ ;

export OneNucleusY =  NewConsonant* ("":"'") NewNucleus NewConsonant* ;
export AddStress123Y =  CDRewrite[ ("" : "'" ) NewNucleus  ,  ("[BOS]" NewConsonant* | NewConsonant+ NewNucleus NewConsonant+ ) , ( NewConsonant+ NewNucleus ), (Sigma | "^" | "_" )* , 'ltr', 'obl' ] ;
export StressY = AddStress123Y @ ( OneNucleusY | (Sigma | "^" | "_" )* - (NewConsonant* NewNucleus NewConsonant*) ) ;
export test = CheckYforYes @ StressY @ CDRewrite[ ("_":"y") | ("^" | "Y") , "", "" , (Sigma | "^" | "_" )* , 'ltr', 'obl' ] ;
```

-8.a

stove/ move/ love

-8.b

-8.c

The regular language defined by Results is starting with 1 stressed vowel which followed by 2 unstressed vowel and repeat or the language with no vowel such as "w". 

> ( Stressed_Vowel Unstressed_Vowel Unstressed_Vowel )* 

> ex. ordering      AO1 R D ER0 IH0 NG

```
# legal example
export Pronounce = StringFile[’data/cmudict.txt’];
input: ordering
output: AO1 R D ER0 IH0 NG

export StressPattern = CDRewrite[(Sigma-bytelib.kDigit) : "", "","",Sigma*,’sim’,’obl’];
input: AO1 R D ER0 IH0 NG
output: 100

# ( 1 stressed vowel followed by 2 unstressed vowel )*
export Dacytl = ("1" | "2") "0" "0"; 
input: 100
output: 100

# Therefore, combining all of this
export Results = Optimize[Project[Pronounce @ StressPattern @ (Dacytl*), ’input’]];
input: ordering
output: ordering
```

> ordinances      AO1 R D AH0 N AH0 N S IH0 Z

```
# illegal example
export Pronounce = StringFile[’data/cmudict.txt’];
input: ordinances
output: AO1 R D AH0 N AH0 N S IH0 Z

export StressPattern = CDRewrite[(Sigma-bytelib.kDigit) : "", "","",Sigma*,’sim’,’obl’];
input: AO1 R D AH0 N AH0 N S IH0 Z
output: 1000

# ( 1 stressed vowel followed by 2 unstressed vowel )*
export Dacytl = ("1" | "2") "0" "0"; 
input: 1000
Rewrite failed.

# Therefore, combining all of this
export Results = Optimize[Project[Pronounce @ StressPattern @ (Dacytl*), ’input’]];
input: ordinances
Rewrite failed.
```


-8.d
```
import 'byte.grm' as bytelib;
import 'arpabet.grm' as arpabet;
Sigma = bytelib.kGraph | bytelib.kSpace;


# get symbol table TH, M, AH0 ....
arpa = SymbolTable['arpabet.sym'];

# parsed the string from byte mode to arpa mode
# take TH as one symbol...
Pronounce = StringFile['cmudict.txt', byte, arpa];

#
StressPattern = CDRewrite[( arpabet.Consonant : "".arpa ) , "".arpa, "".arpa , arpabet.Phoneme* ,  'sim', 'obl'];
Dacytl = ( arpabet.Stressed arpabet.Unstressed arpabet.Unstressed )* ;

export Results = Optimize[Project[Pronounce @ StressPattern @ (Dacytl*), 'input']];
export ListResults = "" : Results;

```

-8.e 
```
# (e.)
# rhyme ending
export Ending = ( arpabet.Phoneme : "".arpa)* arpabet.Stressed  ( arpabet.Phoneme - arpabet.Stressed )* ;

###### Qeust: what "[EOS]" "[BOS]" should be in arpa style ????
###### export Ending = CDRewrite[ ( arpabet.Phoneme : "".arpa ) , "".arpa ,  arpabet.Stressed   ( arpabet.Phoneme - arpabet.Stressed )* "[EOS]"  , arpabet.Phoneme* ,  'sim', 'obl'];
###### [BOS] and [EOS] in arpabet on Piazza.
```

-8.f

domain? bytes(255) + arpabet (70) or Letter(52) + + arpabet (70)

range? 255+70 or 70+52


```
export WordEnding = Optimize[ Pronounce @ Ending ] ;
```

-8.g

the input should be legal input defined by cmudict(a-z), and the output should be a set of words which have same "rhyming ending" which should also be legal words in cumdict.

alphabet(a-z)


-8.h

Time Comlexity to compose two FST is O(v1 v2 d1 (log d2 + m2)), where
> vi = # of states visited, di = maximum out-degree, and mi = maximum multiplicity of the states visited.for the ith FST. 

Thus since WordEnding and Inver[WordEnding] are both quite large and messy, it took a lot of time to compose them.

-8.i

Therefore if we hardcode the input first ("w") and compose with WordEnding, the result FST is quite small which has only one legal input "w" and one single ouput "AH1 B AH0 L Y UW0". 

```
export W_WordEnding = "w" @ WordEnding ;
export W_InvWordEnding = W_WordEnding @ Invert[WordEnding] ;
```

Thus, W_WordEnding @ Invert[WordEnding] is quite fast because the first FST is quite small.

```
export InvWordEnding = ("wood" @ WordEnding) @ Invert[WordEnding] ;

Input string: wood
Output string: would
Output string: understood
Output string: misunderstood
Output string: withstood
Output string: stood
Output string: wood
Output string: could
Output string: good
Output string: schuld
Output string: suhud
Output string: fulwood
Output string: should
Output string: goode
Output string: hood

export InvWordEnding = ("orange" @ WordEnding) @ Invert[WordEnding] ;

Input string: orange
Output string: orange


export InvWordEnding = ("adventureland" @ WordEnding) @ Invert[WordEnding] ;
Input string: adventureland
Rewrite failed.
```

No words has same rhyme as orange.

the FST can't rewrite adventureland since adventureland is not in cmudict.

-8.j

Since regular relations do not include copy languages, we somehow need to get the new Pronounce FST which is a subset of Pronounce with no trivial rhyme ending words before we compose with End.


-9.a

> "001", "011" : 1.7

```
Input string: 001
Output string: 1011

Input string: 011
Output string: 1111

Min-Weight: 1.95
```

-9.b


-9.c

(x,y) = ( 00 , 1)

```
export Flips = ( Zero : (One<1> ) | ( Zero <2>) ) | ( One:  (One<3> ) | ( Zero <4>) ) ;

export a = Flips Flips ;
export WeightedMultipath  =  a  @ ( ( Bit: One <83> ) ( (One : ""  <5> ) | ( Zero: "" <11> ) ) | ( (One: "" <78> ) | ( Zero: ""  <886> ) ) ( Bit: One <66> ) )  ;

export WeightedMultipathOpt = Optimize[WeightedMultipath];

```

There are four output after machine FlipTwice 

```
# flip the input
Input : 00
Output string: 00 <cost=4> 
Output string: 10 <cost=3> 
Output string: 11 <cost=2> 
Output string: 01 <cost=3> 
```

Then we compose this four ouput with WeightedMultipath which will have only one output 1 with 2 different weight. Thus, the result will be 4*2 = 8 different ouputs. 

```
# either transfer the first binary number to 1 and second binary number to "" or transfer the second binary number to 1 and first binary number to "". 

Input : 11 <cost = 2>
Output string: 1 <cost=2+83+5> # this one is minimum = 90
Output string: 1 <cost=2+78+66>

Input : 00 <cost = 4>
Output string: 1 <cost=4+83+11>
Output string: 1 <cost=4+886+66>

Input : 10 <cost = 3>
Output string: 1 <cost=3+83+11>
Output string: 1 <cost=3+78+66>

Input : 01 <cost = 3>
Output string: 1 <cost=3+83+5>
Output string: 1 <cost=3+886+66>

```

Therefore, there are 8 different paths and 8 different weights.

```
T_out = Project[ T, ’output’]; # erases input from T
```
Only Allowing possible T's ouput string to pass T_out
```
xT_out = Project[ x @ T, ’output’]; # erases input x from x @ T
```
Only Allowing possible T's ouput string given x to T to pass xT_out
```
Ty_in = Project[ T @ y, ’input’]; # erases output y from T @ y
```
Only Allowing possible T's input string given ouput y of T to pass Ty_in

```
xTy = x @ T @ y;
```
For given (x,y), if there is a path from x to y in T, the xTy will ouput y as result. Otherwise, return Rewrite failed.
```
exTye = ("":x) @ T @ (y:""); #erasesinputx&outputyfromx@T@y
```
Same as xTy but only ouput "" if there is a legal path, otherwise, return Rewrite failed.


Thus, if we only want to check any possible ouput can be generated by x @ T, using Optimize[xT_out] is quite efficient since the FST graph of Optimize[xT_out] is smaller than the graph of x @ T.

To check any possible input which has at least one path to y in T, we would like to use Optimize[Ty_in].

To cehck if there is any path from x to y in T, we would like to use Optimize[exTye].


-9.d

```
export NoDet = ( "1" : ( "1" <1> )* ) ;

```


-10.a



-10.d

Thank is not in entrain.sym

-10.e

```
export CompleteWord = (( ByteSigma+  ( "" :  ByteSigmaStar ) ) @ Invert[Spell]) @ LM ;

Input string: barr
Output string: barriers <cost=19.314678>
Output string: barrels <cost=19.616245>
Output string: barrel <cost=19.993179>
Output string: barrage <cost=20.031265>
Output string: barrier <cost=20.048843>


Input string: barriers
Output string: barriers <cost=19.314991>
Input string: barrels
Output string: barrels <cost=19.615818>
Input string: barrel
Output string: barrel <cost=19.993179>
Input string: barrage
Output string: barrage <cost=20.031345>
Input string: barrier
Output string: barrier <cost=20.048569>
Input string: barriers 
```

Only "barrels" cost equal to the unigram probability of word. Other results are slightly different from the unigram probabiliy. 



-11.e.i

w1 is the - log probability of there is another randomchar after current char

w2 is the - log probability of there is no char after current char
 
> Notice that exp(-w1) + exp(-w2) = 1

-11.e.ii

p_n = (1/94)^n * 0.9^{n-1} * 0.1

-11.e.iii

sum p_n = 0.1/94 sum (0.9/94)^{n-1} = 0.1/94  * ( 1 - r^n ) / 1- r

-11.e.iv

dncrease w1 such that exp(-w1) + exp(-w2) = 1

-11.e.v

Then exp(-w1) + exp(-w2) > 1, which we can not trnasfer back to probability unless we normalize it first

The cost of random words will decrease

-11.e.vi

If we only care about words, maybe we can consider bytelib.kAlpha instead of bytelib.kGraph which also includes the punc, number and space. Therefore, we can assign weight 1.71600 to RandomChar. 

For RandomWord, since the average length of word is 5.1, we would like to increase w1 and decrease w2 to avoid long letters word.


```
# (a.)

export DelSpaces = Optimize[CDRewrite[ " ": "" , "", "", ByteSigmaStar, 'ltr', 'obl' ]] ;


# (b.)


# (c.) (d.)

export SpellTextByteToVocab =  (ByteSigma+ @ Invert[Spell] ("" : " ".vocab ) )* ;
export SpellText =  ( Spell @ (ByteSigma - " " )+ ) ( (" ".vocab : " ") ( Spell @ (ByteSigma - " " )+ )  )*  ;

Generate =  LM @ ( SpellText @ DelSpaces ) ;
# Decode = ( (( ByteSigmaStar @ Invert[DelSpaces]) @ Invert[SpellText] ) @ Invert[LM] ) @ SpellText ;

Decode = ( "ifonly" @ Invert[Generate] ) @ SpellText ;



# (e.)

export RandomChar = bytelib.kGraph <4.54>;
export RandomWord = Optimize[(RandomChar (RandomChar <0.1>)* ) <2.3>];
export SpellOOV = "<unk>".vocab : RandomWord;


# (f.)

export RSpell = Spell | ( SpellOOV : "<unk>" )  ;

TextTrans =  ( RSpell @ (ByteSigma - " " )+ ) ;
PrintText = ( TextTrans ) ( (" ".vocab : " ") TextTrans  )*  ;

RGenerate =  LM @ ( PrintText @ DelSpaces ) ;
export RDecode = ( "ifonly" @ Invert[RGenerate] ) @ SpellText ;

```


